<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Hybrid Subtitle Tool - Optional Learning</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <style>
        body { font-family: 'Helvetica Neue', Arial, sans-serif; text-align: center; background: #1a1a1a; color: #eee; padding: 20px; margin: 0; }
        .controls { background: #333; padding: 15px; border-radius: 10px; margin-bottom: 10px; display: flex; flex-wrap: wrap; justify-content: center; gap: 15px; align-items: center; }
        .btn { padding: 8px 20px; font-size: 1rem; cursor: pointer; border: none; border-radius: 5px; font-weight: bold; transition: 0.3s; }
        #startBtn { background: #27ae60; color: white; }
        #startBtn:hover { background: #2ecc71; }
        #pipBtn { background: #2980b9; color: white; }
        .pdf-section { background: #444; padding: 10px; border-radius: 5px; font-size: 0.8rem; border: 1px dashed #666; }
        #canvasContainer { background: #000; padding: 10px; display: flex; justify-content: center; }
        #subtitleCanvas { border: 1px solid #444; width: 100%; max-width: 900px; height: auto; }
        #debugLog { background: #000; color: #0f0; padding: 10px; height: 60px; overflow-y: scroll; font-size: 0.7rem; text-align: left; border-top: 1px solid #333; font-family: monospace; }
        select { padding: 8px; border-radius: 5px; background: #fff; }
    </style>
</head>
<body>

<div class="controls">
    <div class="pdf-section">
        <strong>ã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã€‘</strong> æˆæ¥­ã‚¹ãƒ©ã‚¤ãƒ‰(PDF): 
        <input type="file" id="pdfUpload" accept="application/pdf">
        <span id="pdfStatus" style="color: #bbb;">æœªèª­ã¿è¾¼ã¿ï¼ˆæ¨™æº–ãƒ¢ãƒ¼ãƒ‰ï¼‰</span>
    </div>
    <select id="langMode">
        <option value="ja|en">ğŸ‡¯ğŸ‡µ æ—¥ â†’ è‹±</option>
        <option value="en|ja">ğŸ‡ºğŸ‡¸ è‹± â†’ æ—¥</option>
    </select>
    <button id="startBtn" class="btn">1. éŸ³å£°èªè­˜ã‚’é–‹å§‹</button>
    <button id="pipBtn" class="btn" style="display:none;">2. å­—å¹•ã‚’æµ®ã‹ã›ã‚‹</button>
</div>

<div id="canvasContainer">
    <canvas id="subtitleCanvas" width="1000" height="200"></canvas>
</div>
<video id="videoElement" autoplay playsinline muted style="display:none;"></video>
<div id="debugLog">>> ã‚·ã‚¹ãƒ†ãƒ å¾…æ©Ÿä¸­...</div>

<script>
    const startBtn = document.getElementById('startBtn');
    const pipBtn = document.getElementById('pipBtn');
    const langMode = document.getElementById('langMode');
    const pdfUpload = document.getElementById('pdfUpload');
    const pdfStatus = document.getElementById('pdfStatus');
    const canvas = document.getElementById('subtitleCanvas');
    const ctx = canvas.getContext('2d');
    const video = document.getElementById('videoElement');
    const log = document.getElementById('debugLog');

    let recognition;
    let currentTranslatedText = "";
    let currentInterimText = "";
    let glossary = []; // PDFã‹ã‚‰æŠ½å‡ºã—ãŸç”¨èªãƒªã‚¹ãƒˆ

    // 1. ãƒ­ã‚°è¡¨ç¤ºé–¢æ•°
    function addLog(msg) {
        const div = document.createElement('div');
        div.textContent = `> ${msg}`;
        log.appendChild(div);
        log.scrollTop = log.scrollHeight;
    }

    // 2. PDFèª­ã¿è¾¼ã¿ï¼ˆä»»æ„ï¼‰
    pdfUpload.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        pdfStatus.innerText = "è§£æä¸­...";
        pdfStatus.style.color = "#f1c40f";
        
        const reader = new FileReader();
        reader.onload = async function() {
            try {
                const typedarray = new Uint8Array(this.result);
                const pdf = await pdfjsLib.getDocument(typedarray).promise;
                let fullText = "";
                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const content = await page.getTextContent();
                    fullText += content.items.map(item => item.str).join(' ');
                }
                // å°‚é–€ç”¨èªï¼ˆ2æ–‡å­—ä»¥ä¸Šã®æ¼¢å­—ã€ã¾ãŸã¯4æ–‡å­—ä»¥ä¸Šã®è‹±å˜èªï¼‰ã‚’æŠ½å‡º
                glossary = [...new Set(fullText.match(/[A-Z]{2,}|[a-zA-Z]{4,}|[\u4e00-\u9faf]{2,}/g) || [])];
                addLog(`PDFã‚’å­¦ç¿’ã—ã¾ã—ãŸï¼ˆ${glossary.length}èªï¼‰ã€‚ã“ã®ç”¨èªã‚’å„ªå…ˆã—ã¦èªè­˜ã—ã¾ã™ã€‚`);
                pdfStatus.innerText = "å­¦ç¿’æ¸ˆã¿ãƒ¢ãƒ¼ãƒ‰";
                pdfStatus.style.color = "#2ecc71";
            } catch (err) {
                addLog("PDFèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: æ¨™æº–ãƒ¢ãƒ¼ãƒ‰ã§ç¶šè¡Œã—ã¾ã™ã€‚");
                pdfStatus.innerText = "ã‚¨ãƒ©ãƒ¼ï¼ˆæ¨™æº–ãƒ¢ãƒ¼ãƒ‰ï¼‰";
            }
        };
        reader.readAsArrayBuffer(file);
    };

    // 3. ç”¨èªè£œæ­£ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆglossaryãŒç©ºãªã‚‰ä½•ã‚‚ã—ãªã„ï¼‰
    function correctText(text) {
        if (!glossary || glossary.length === 0) return text;
        let corrected = text;
        glossary.forEach(term => {
            if (term.length > 2 && text.toLowerCase().includes(term.toLowerCase())) {
                const regex = new RegExp(term, 'gi');
                corrected = corrected.replace(regex, term);
            }
        });
        return corrected;
    }

    // 4. å­—å¹•æç”»
    function wrapText(context, text, x, y, maxWidth, lineHeight) {
        const words = text.split('');
        let line = '';
        for(let n = 0; n < words.length; n++) {
            let testLine = line + words[n];
            if (context.measureText(testLine).width > maxWidth && n > 0) {
                context.fillText(line, x, y);
                line = words[n];
                y += lineHeight;
            } else { line = testLine; }
        }
        context.fillText(line, x, y);
    }

    function updateDisplay() {
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        // ä¸Šéƒ¨ï¼šèªè­˜ä¸­ã®æ–‡å­—
        ctx.fillStyle = '#999';
        ctx.font = '20px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(currentInterimText, canvas.width / 2, 35);
        // ä¸­å¤®ï¼šç¿»è¨³å­—å¹•ï¼ˆã‚µã‚¤ã‚º32pxï¼‰
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 32px sans-serif';
        wrapText(ctx, currentTranslatedText, canvas.width / 2, 90, 920, 45);
    }

    // 5. éŸ³å£°èªè­˜ã®è¨­å®š
    if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        recognition = new SpeechRecognition();
        recognition.continuous = true;
        recognition.interimResults = true;

        recognition.onresult = async (event) => {
            let interimTranscript = '';
            for (let i = event.resultIndex; i < event.results.length; ++i) {
                let transcript = event.results[i][0].transcript;
                if (event.results[i].isFinal) {
                    transcript = correctText(transcript); // ã“ã“ã§è£œæ­£ï¼ˆä»»æ„ï¼‰
                    const [source, target] = langMode.value.split('|');
                    try {
                        const res = await fetch(`https://api.mymemory.translated.net/get?q=${encodeURIComponent(transcript)}&langpair=${source}|${target}`);
                        const data = await res.json();
                        currentTranslatedText = data.responseData.translatedText;
                    } catch (e) { addLog("ç¿»è¨³å¤±æ•—"); }
                } else {
                    interimTranscript += transcript;
                }
            }
            currentInterimText = interimTranscript;
            updateDisplay();
        };
        recognition.onend = () => { if(recognition) recognition.start(); };
    }

    startBtn.onclick = () => {
        const [source, target] = langMode.value.split('|');
        recognition.lang = (source === 'ja') ? 'ja-JP' : 'en-US';
        recognition.start();
        startBtn.style.display = 'none';
        pipBtn.style.display = 'inline-block';
        const stream = canvas.captureStream(10);
        video.srcObject = stream;
        video.play();
        addLog(`èªè­˜ã‚’é–‹å§‹ã—ã¾ã—ãŸ (${source === 'ja' ? 'æ—¥æœ¬èª' : 'è‹±èª'}ãƒ¢ãƒ¼ãƒ‰)`);
    };

    pipBtn.onclick = () => video.requestPictureInPicture();
    
    // åˆæœŸæç”»
    updateDisplay();
</script>
</body>
</html>