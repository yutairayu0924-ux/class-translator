<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Lecture Subtitle - Event Edition</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <style>
        body { font-family: sans-serif; text-align: center; background: #1a1a1a; color: #eee; margin: 0; padding: 10px; }
        .setup-panel { background: #333; padding: 15px; border-radius: 10px; margin-bottom: 10px; display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .control-panel { background: #444; padding: 15px; border-radius: 10px; margin-bottom: 10px; }
        .btn { padding: 12px 24px; font-size: 1.1rem; cursor: pointer; border: none; border-radius: 5px; font-weight: bold; margin: 5px; }
        .btn-green { background: #27ae60; color: white; }
        .btn-blue { background: #2980b9; color: white; }
        .btn-switch { background: #f39c12; color: white; width: 100%; max-width: 400px; font-size: 1.5rem; }
        textarea { width: 90%; height: 60px; background: #222; color: #fff; border: 1px solid #555; padding: 5px; font-size: 0.8rem; }
        #subtitleCanvas { border: 2px solid #555; background: #000; width: 100%; max-width: 1000px; height: auto; }
        #status-bar { font-size: 1.2rem; font-weight: bold; color: #f1c40f; margin: 10px 0; }
    </style>
</head>
<body>

<div class="setup-panel">
    <div>
        <strong>1. ç”¨èªå­¦ç¿’ (PDF)</strong><br>
        <input type="file" id="pdfUpload" accept="application/pdf">
    </div>
    <div>
        <strong>2. æ‰‹å‹•ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ç™»éŒ² (ç”»åƒã‚¹ãƒ©ã‚¤ãƒ‰å¯¾ç­–)</strong><br>
        <textarea id="manualKeywords" placeholder="å°‚é–€ç”¨èªã‚’ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šã§å…¥åŠ›ï¼ˆä¾‹: AI, æ©Ÿæ¢°å­¦ç¿’, Quantum...ï¼‰"></textarea>
    </div>
</div>

<div class="control-panel">
    <div id="status-bar">ç¾åœ¨ã®ãƒ¢ãƒ¼ãƒ‰: <span id="modeDisplay">æº–å‚™ä¸­</span></div>
    <button id="toggleLang" class="btn btn-switch">ğŸ”„ è¨€èªã‚’å…¥ã‚Œæ›¿ãˆã‚‹</button>
    <br>
    <button id="startBtn" class="btn btn-green">ğŸ¤ èªè­˜é–‹å§‹</button>
    <button id="pipBtn" class="btn btn-blue" style="display:none;">ğŸ“º å­—å¹•ã‚’æœ€å‰é¢ã«å‡ºã™</button>
</div>

<canvas id="subtitleCanvas" width="1000" height="200"></canvas>
<video id="videoElement" autoplay playsinline muted style="display:none;"></video>

<script>
    const startBtn = document.getElementById('startBtn');
    const pipBtn = document.getElementById('pipBtn');
    const toggleLang = document.getElementById('toggleLang');
    const modeDisplay = document.getElementById('modeDisplay');
    const manualKeywords = document.getElementById('manualKeywords');
    const pdfUpload = document.getElementById('pdfUpload');
    const canvas = document.getElementById('subtitleCanvas');
    const ctx = canvas.getContext('2d');
    const video = document.getElementById('videoElement');

    let recognition;
    let isJaToEn = true; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯æ—¥â†’è‹±
    let currentTranslatedText = "";
    let currentInterimText = "";
    let glossary = [];

    function updateModeDisplay() {
        modeDisplay.innerText = isJaToEn ? "ğŸ‡¯ğŸ‡µ æ—¥æœ¬èª â†’ ğŸ‡ºğŸ‡¸ è‹±èª" : "ğŸ‡ºğŸ‡¸ è‹±èª â†’ ğŸ‡¯ğŸ‡µ æ—¥æœ¬èª";
    }
    updateModeDisplay();

    // è¨€èªåˆ‡ã‚Šæ›¿ãˆãƒœã‚¿ãƒ³
    toggleLang.onclick = () => {
        isJaToEn = !isJaToEn;
        updateModeDisplay();
        if (recognition) {
            recognition.stop(); // è¨€èªè¨­å®šã‚’åæ˜ ã•ã›ã‚‹ãŸã‚ã«ä¸€åº¦æ­¢ã‚ã‚‹ï¼ˆonendã§è‡ªå‹•å†èµ·å‹•ï¼‰
            recognition.lang = isJaToEn ? 'ja-JP' : 'en-US';
        }
    };

    // PDFèª­ã¿è¾¼ã¿
    pdfUpload.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = async function() {
            const typedarray = new Uint8Array(this.result);
            const pdf = await pdfjsLib.getDocument(typedarray).promise;
            let fullText = "";
            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const content = await page.getTextContent();
                fullText += content.items.map(item => item.str).join(' ');
            }
            glossary = [...new Set([...glossary, ...(fullText.match(/[A-Z]{2,}|[a-zA-Z]{4,}|[\u4e00-\u9faf]{2,}/g) || [])])];
            alert("PDFã‹ã‚‰å­¦ç¿’ã—ã¾ã—ãŸ");
        };
        reader.readAsArrayBuffer(file);
    };

    function correctText(text) {
        // æ‰‹å‹•å…¥åŠ›ã•ã‚ŒãŸã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚‚è¿½åŠ 
        const manual = manualKeywords.value.split(/[,ã€\s]+/).filter(w => w.length > 0);
        const activeGlossary = [...new Set([...glossary, ...manual])];
        
        let corrected = text;
        activeGlossary.forEach(term => {
            if (term.length > 2 && text.toLowerCase().includes(term.toLowerCase())) {
                const regex = new RegExp(term, 'gi');
                corrected = corrected.replace(regex, term);
            }
        });
        return corrected;
    }

    function draw() {
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#999';
        ctx.font = '20px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(currentInterimText, canvas.width / 2, 35);
        ctx.fillStyle = 'white';
        ctx.font = 'bold 34px sans-serif';
        
        // ãƒ†ã‚­ã‚¹ãƒˆæŠ˜ã‚Šè¿”ã—å‡¦ç†
        const maxWidth = 920;
        const lineHeight = 45;
        let words = currentTranslatedText.split('');
        let line = '';
        let y = 90;
        for(let n = 0; n < words.length; n++) {
            let testLine = line + words[n];
            if (ctx.measureText(testLine).width > maxWidth && n > 0) {
                ctx.fillText(line, canvas.width / 2, y);
                line = words[n];
                y += lineHeight;
            } else { line = testLine; }
        }
        ctx.fillText(line, canvas.width / 2, y);
    }

    if ('webkitSpeechRecognition' in window) {
        recognition = new webkitSpeechRecognition();
        recognition.continuous = true;
        recognition.interimResults = true;

        recognition.onresult = async (event) => {
            let interim = '';
            for (let i = event.resultIndex; i < event.results.length; ++i) {
                let transcript = event.results[i][0].transcript;
                if (event.results[i].isFinal) {
                    transcript = correctText(transcript);
                    const source = isJaToEn ? 'ja' : 'en';
                    const target = isJaToEn ? 'en' : 'ja';
                    const res = await fetch(`https://api.mymemory.translated.net/get?q=${encodeURIComponent(transcript)}&langpair=${source}|${target}`);
                    const data = await res.json();
                    currentTranslatedText = data.responseData.translatedText;
                } else {
                    interim += transcript;
                }
            }
            currentInterimText = interim;
            draw();
        };
        recognition.onend = () => { recognition.start(); };
    }

    startBtn.onclick = () => {
        recognition.lang = isJaToEn ? 'ja-JP' : 'en-US';
        recognition.start();
        startBtn.style.display = 'none';
        pipBtn.style.display = 'inline-block';
        video.srcObject = canvas.captureStream(10);
        video.play();
    };

    pipBtn.onclick = () => video.requestPictureInPicture();
    draw();
</script>
</body>
</html>